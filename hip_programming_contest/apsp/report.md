# GPU 全对最短路径程序设计报告

## 引言

本次任务的目标是实现一个基于 HIP 的全对最短路径（All-Pairs Shortest Path, APSP）程序。APSP 是图论中的经典问题，需要计算图中任意两个顶点之间的最短路径距离。该问题在路由算法、网络分析和社交网络分析等领域有广泛应用。设计的重点不仅在于保证算法的正确性，还在于在 GPU 上充分发挥并行性能，并在评测时兼顾整体运行时间，包括数据传输与初始化开销。

## 开发过程

最初的实现采用了传统的 Floyd-Warshall 算法，该算法的时间复杂度为 O(V³)，适合在 GPU 上并行化。然而，直接实现存在内存访问模式不佳、缓存命中率低等问题。为了优化性能，我们采用了分块 Floyd-Warshall 算法，将 V×V 的距离矩阵划分为多个 B×B 的块，通过三个阶段的计算来减少内存访问次数并提高缓存利用率。

在实现过程中，我们遇到了几个关键挑战。首先是内存管理问题：原始实现需要在每次计算时进行主机到设备的数据传输，这成为了性能瓶颈。通过引入 `APSP_Solver` 类，我们实现了持久化的 GPU 资源管理，将图数据一次性传输到 GPU 并保持在设备内存中，避免了重复的数据传输开销。

其次是分块算法的正确性保证。分块 Floyd-Warshall 算法分为三个阶段：Phase 1 更新对角线块，Phase 2 更新与对角线块同行同列的块，Phase 3 更新剩余块。每个阶段都需要正确的同步和内存访问模式。通过使用共享内存和适当的线程同步，我们确保了算法的正确性。

性能分析表明，GPU 核函数的执行效率很高，在中等规模的图上（如 1000 个顶点），纯 GPU 计算部分仅需数毫秒。然而，最大的开销仍然来自 HIP 的首次初始化，这与前缀和程序遇到的问题类似。通过将 HIP 初始化提前到 `main` 函数，并通过单独线程与文件 I/O 并行执行，我们成功隐藏了初始化开销。

同样考虑到评测统计的是整个程序的运行时间，文件 I/O 的优化也至关重要。我们实现了快速读入函数 `read_int()` 和带缓冲区的快速输出函数，避免了标准库的额外开销。对于大规模图数据，这种优化带来了显著的性能提升。

## 最终方案

最终实现的方案包括以下要点：

* **核心算法**：分块 Floyd-Warshall 算法，通过三个阶段的计算实现高效的全对最短路径计算，充分利用 GPU 的并行计算能力。
* **内存管理**：使用 `APSP_Solver` 类实现持久化的 GPU 资源管理，输入和输出数组分配在页锁定内存中，以加快数据传输速度。
* **初始化优化**：HIP 初始化通过后台线程提前完成，与文件读取并行，从而消除了对整体耗时的影响。
* **I/O 优化**：实现快速读入和带缓冲区的输出函数，减少系统调用开销。

## 算法设计

### 分块 Floyd-Warshall 算法

分块 Floyd-Warshall 算法将 V×V 的距离矩阵 D 划分为 ⌈V/B⌉×⌈V/B⌉ 个 B×B 的块，其中 B 是块大小。对于每个块索引 k（从 0 到 ⌈V/B⌉-1），算法执行以下三个阶段：

1. **Phase 1 - 对角线块更新**：计算对角线块 (k,k) 内的最短路径，考虑块内顶点作为中间点。
2. **Phase 2 - 行和列更新**：使用新计算的对角线块距离更新同一行和同一列的块。
3. **Phase 3 - 剩余块更新**：对于所有不在对角线、行、列上的块，使用公式 D[i,j] ← min(D[i,j], D[i,k] + D[k,j]) 更新距离。

### GPU 实现细节

每个阶段都使用专门的 kernel 函数实现：

- `floyd_warshall_block_kernel_phase1`：处理对角线块，使用共享内存存储块数据，通过 `block_calc` 函数执行块内计算。
- `floyd_warshall_block_kernel_phase2_row` 和 `floyd_warshall_block_kernel_phase2_col`：分别处理行和列的更新。
- `floyd_warshall_block_kernel_phase3`：处理剩余块的更新。

所有 kernel 都使用共享内存来减少全局内存访问，并通过适当的填充（stride = b + 1）避免 bank 冲突。

## 结果与分析

在测试用例上的表现：

* 所有 10 个测试用例均通过，总执行时间约 6.97 秒。
* 单个测试用例的执行时间在 0.44 秒到 2.02 秒之间，主要取决于图的规模。
* 通过分块算法和内存优化，GPU 计算部分效率显著提升。

性能优化的效果：

* 通过持久化的 GPU 资源管理，避免了重复的数据传输开销。
* 分块算法提高了缓存命中率，减少了内存访问延迟。
* 初始化并行化和 I/O 优化显著降低了整体运行时间。

## 总结与展望

本次工作实现了一个正确且高效的 GPU 全对最短路径程序，开发过程中解决了内存管理、分块算法实现、初始化开销等多个实际问题。在算法层面，分块 Floyd-Warshall 算法结合共享内存优化已能满足需求；在工程层面，通过持久化资源管理和初始化并行化显著降低了整体耗时。

未来的改进方向包括：进一步优化分块大小以适应不同的图规模；探索其他并行最短路径算法（如 Johnson 算法）在 GPU 上的实现；以及尝试多 GPU 并行化以处理更大规模的图。

总体而言，本次开发不仅让我实现了一个高性能的 GPU 全对最短路径程序，也让我深入理解了 GPU 编程中算法设计与工程优化的重要性，特别是在处理大规模图数据时的内存管理和并行化策略。
